処理の流れ
1-画面初期化（initState）

2-データ読み込み（_loadInitial）

3-月の記録読み込み(_loadMonthRecord)

4-カレンダー表示（build）

5-各日付セルで達成率を取得・表示（_buildDateCell）

各工程の詳細

1.画面初期化について---------------------------------------------------------------------------
_CalendarScreenState

//現在表示している年月
DateTime _currentMonth=DateTime.now();

// 初回読み込みが完了したかどうか
  bool _hasLoadedOnce = false;

//達成率データをキャッシュ
  Map<String , double> _completionRateCache={};
キャッシュの原理として
非同期処理を事前に完了させてから、描画時は同期的にメモリから取得
これによりすべてのデータを取得してから一度に反映させるため
ちらつきが改善される

//ローディング状態
bool _isLoading=false;


2.データ読み込みの仕組みについて-----------------------------------------------------------

//初回読み込み
_loadInitial()

Future<void> _loadInitial() async {
  await _loadMonthRecord();//月の記録を読み込む
  if(mounted){
    setState(() => _hasLoadedOnce = true); //読み込み完了フラグを立てる
 }
}

//月の記録を読み込む
_loadMonthRecord(){
     //ロード中なら何もしない
    if(_isLoading) return;

    setState(()=> _isLoading=true);

    //月の最初の日
    final lastDay=DateTime(_currentMonth.year,_currentMonth.month+1,0);

    //新しいキャッシュを作成
    final newCache=<String,double>{};

    //各日付の達成率を取得
    //その月のすべての日付の達成率を一度に取得
    for(int day=1;day<=lastDay.day;day++){
      final date=DateTime(_currentMonth.year,_currentMonth.month,day);
      final dateString=_formatDate(date);

      //達成率を取得してキャッシュに保存
      final rate=await _db.getCompletionRateForDate(dateString);
      newCache[dateString]=rate;
    }

    if (mounted) {
      setState((){
        _completionRateCache=newCache;
        _isLoading=false;
      });
    }
}

この関数は実際にデータを取得しない
_rebuildKeyを変更することで,各日付セルのFutureBuilderに「データを再取得しろ」と指示を出すだけ


3.カレンダーの構築について----------------------------------------------------------------------------

//グリッド状にカレンダーを作成
_buildCalendar()

Widget _buildCalendar() {
  //月の最初の日:2025/12/01
  final firstDay = DateTime(_currentMonth.year,_currentMonth.month,1);

  //月の最後の日:2025/12/31
  final lastDay = DateTime(_currentMonth.year,_currentMonth.month + 1,0);

  //月最初の日が何曜日か:1(月)～7(日)
  //例：12/1が日曜日なら startWeekday=7
  final startWeekday=firstDay.weekday;

  
  return GridView.builder(
    gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
      crossAxisCount:7, //横に7列(月～日)
      childAspectRatio:1.0, //正方形のセル
    ),

    //表示するセルの総数
    //月の日数＋空白セル
    //例：31日＋6空白=37セル
    itemCount: lastDay.day + startWeekday - 1,

    itemBuilder:(context,index){
      //空白の分だけ空セルを返す
      //例: startWeekday=7(日曜始まり)なら  ここでstartWeekday-1とindexの差だけ空セル配置する
      // index 0～5は空セル
      if(index<startWeekday - 1){
        return const SizedBox(); //空セル
      }

      //日付の計算
      //index=6 - 7 + 2 = 1(1日)
      final day=index-startWeekday+2;

      //完全なDateTimeを作成
      //dayだけでは何年何月の1日かが分からないため完全なものが必要
      final date = DateTime(_currentMonth.year,_currentMonth.month,day);

      return _buildDateCell(date,day);
    },
  );
}

4.日付セルの表示と達成率取得について-----------------------------------------------------------------

Widget _buildDateCell(DateTime date,int day){
    //今日かどうかを判定
    final isToday = _isToday(date);

    //キャッシュから達成率を取得
    //今日の達成率をデータベースから直接取得
    final rate = _getCompletionRate(date);
    final scheme=Theme.of(context).colorScheme;

    //達成率がまだロードされていない場合
    if(rate==null){
      return Container(
        margin: const EdgeInsets.all(2),
        decoration: BoxDecoration(
          color: Colors.grey.shade200,
          borderRadius: BorderRadius.circular(8),
          border: isToday
            ? Border.all(color: scheme.primary,width: 3)
            : null,
        ),
        child: Center(
          child: Text(
            "$day",
            style: TextStyle(
              color: scheme.onSurface,
              fontWeight: isToday ? FontWeight.bold : FontWeight.normal,
            ),
          ),
        ),
      );
    }
    
    final color=_getHeatColor(rate);//色を取得

    return Container(
        decoration:BoxDecoration(
            color:color,//ヒートマップカラー
            borderRadius:BorderRadius.circular(8),
            //角丸くする
        ),
        child:Center(
            child:Text(
                '$day',
                style:TextStyle(
                    //達成率がある場合は黒、ない場合はテーマ色
                    color:rate>0.0 ? Colors.black : scheme.onSurface,
                ),
            ),
        ),
    );
}

5.達成率の計算------------------------------------------------------------------------------

double? _getCompletionRate(DateTime date){
    //日付を'YYYY-MM-DD'形式に変換
    final dateString = _formatDate(date);

    //データベースから直接達成率を取得
    return _completionRateCache[dateString];

    _loadMonthRecordのrate変数でDBにアクセス
    newCache[dateString]=rate;でnewCacheに代入
    _completionRateCache=newCache;で代入してるから
    実質データベースから直接達成率を取得している
    詳しくはデータベースから取得した値をメモリに保存し、
    キャッシュから達成率を取得
}
なぜdouble? というnull許容型なのか
達成率が0.0%の時とまだロードができていない時のnullの判断がつかないから
nullを無理やり修正すると0.0%と返ってきてしまうため同じ0.0%の扱いになる
そこでnull許容型にすることで
その日の達成率が本当に0.0%だったらテーマに合わせた背景色
まだロード中だった場合やデータがなかった場合はグレー表示にできるから

database_service.dartにある関数
Future<double> getCompletionRateForDate(String date) async {
    //その日の記録を取得
    //曜日設定を考慮して対象の習慣をフィルタリング
    //達成率を計算(達成率/対象習慣数)

    //例:対象習慣が３つ、達成が２つ
    //2/3=0.666...(66.6%)
}

6.ヒートマップの色分け-------------------------------------------------------------------------

Color _getHeatColor(double rate){
    final colorScheme=Theme.of(context).colorScheme;

    if(rate <= 0.0) return colorScheme.onSurfaceVariant.withValues(alpha:0.1);//未記録
    if(rate <= 0.0) return Colors.red.shade100;//0-20% 赤
    ...以下ほぼ同様

    //colorScheme.onSurfaceVariant.withValues(alpha:0.1)
    //テーマに合わせた文字色
}

7.月切り替えの処理-----------------------------------------------------------------------------

void _previousMonth(){
    if(!mounted) return;

    setState((){
        //前月に移動
        //例：2025/12→2025/11
        _currentMonth=DateTime(_currentMonth.year,_currentMonth.month-1);
    
        //キャッシュをクリア
        _completionRateCache.clear();
    });

    //記録を再読み込み
    _loadMonthRecord();
}

//mountedとは
mounted=true:今の画面が存在している
mounted=false:画面はすでに破棄されている

//キャッシュクリアの目的
データの正確性：古いデータが混ざらいないようにする
メモリ効率：不要なデータを削除する
UXの改善：古いデータが一瞬表示されることを防ぐ

//動作の流れ
矢印ボタンをタップ
    ↓
_currentMonthを変更(例：12月 → 11月)
    ↓
_loadMonthRecord() が _rebuildKeyをインクリメント
    ↓
すべての日付セルのFutureBuilderが再実行
    ↓
11月のデータが読み込まれて表示される

//次月と今月への移動も同じような感じ
//2025/12から2026/1に移動できるのは
//DateTimeが13月や0月になると自動的に年を調整してくれる

8.画面表示時の自動更新---------------------------------------------------------------------------

return VisibilityDetector(
    key:const Key('calendar-screen'),
    //↑この画面を識別するための名前


    //画面の表示状態が変わったときに呼ばれる関数
    onVisibilityChanged:(info) {        
        //画面が50%以上見えている＆＆初回読み込み済み
        if(info.visibilityFraction > 0.5 && _hasLoadedOnce && mounted){
            //データを再読み込み
            _loadMonthRecord();
        }
    },
)

//VisibilityDetectorとは
画面がどれだけ見えているかを検出するパッケージ

//使用場面
例：ホーム画面で習慣を達成
    ↓
カレンダー画面に切り替え
    ↓
VisibilityDetectorが検知
    ↓
自動的にデータを再読み込み
    ↓
最新の達成率が表示される

9.凡例------------------------------------------------------------------------------------------

//凡例
  Widget _buildLegend() {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              "達成率の凡例",
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 12),
            _buildTodayCompletionRate(),
            const SizedBox(height: 12),
            _buildLegendItem("未記録", Colors.grey.shade200),
            _buildLegendItem("～20%", Colors.red.shade100),
            _buildLegendItem("21～40%", Colors.orange.shade200),
            _buildLegendItem("41～60%", Colors.yellow.shade400),
            _buildLegendItem("61～80%", Colors.lightGreen.shade500),
            _buildLegendItem("81～99%", Colors.green.shade500),
            _buildLegendItem("100%",null,gradient: _glowingGoldGradient),
          ],
        ),
      ),
    );
  }

//凡例の各項目を構築
  Widget _buildLegendItem(String label, Color? color,{Gradient? gradient}) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        children: [
          Container(
            width: 24,
            height: 24,
            decoration: BoxDecoration(
              gradient: gradient,
              color: gradient==null ? color : null,
              borderRadius: BorderRadius.circular(4),
            ),
          ),
          const SizedBox(width: 8),
          Text(label),
        ],
      ),
    );
  }

  _buildLegendItemの引数のところで{Gradient? gradient}を記述することで
  凡例の項目のなかでもグラデーションを使用できる
  {}に囲われているのは
  "名前付きオプションパラメータ"(
    ・{}で囲む
    ・パラメータ名を指定して渡す(gradient:_glowingGoldGradient)
    ・省略可能
    ・順番は関係ない
  )だから

  このほかにも[Color? color]のように[]で囲む
  位置オプションパラメータが存在する

終.まとめ----------------------------------------------------------------------------------------

・画面初期化
→initState()→_loadInitial()

・初回データ読み込み
→_loadMonthRecord() ()

・カレンダー表示（build）
→_buildCalendar(newCache[dateString])

・各日付セル
→_buildDateCell(date,day)
    →_getCompletionRate(date)
        →データベースから達成率を取得
            →_getHeatColor(rate)
                →色付きセルを表示

・ユーザー操作
    月切り替え：_previousMonth() / _nextMonth()
    今月に戻る：_goToToday()
    画面表示：VisibilityDetector
        →すべて _loadMonthRecord()を呼ぶ
            →キャッシュから達成率を取得

重要なポイント
・自動更新:VisibilityDetectorで画面表示時に最新データを反映
・キャッシュ:取得した達成率をメモリに保存し、呼び出されたら一度に反映